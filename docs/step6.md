## 1. 학습 목표

- 세션 정보를 바탕으로 주어인 요청에 대해 동적인 HTML을 응답하도록 구현할 수 있다.

---

## 2. 기능 요구사항

- 사용자가 로그인 상태일 경우 /index.html에서 사용자 이름을 표시해 준다.
- 사용자가 로그인 상태가 아닐 경우 /index.html에서 [로그인] 버튼을 표시해 준다.
- 사용자가 로그인 상태일 경우 http://localhost:8080/user/list 에서 사용자 목록을 출력한다.
- http://localhost:8080/user/list  페이지 접근시 로그인하지 않은 상태일 경우 로그인 페이지(login.html)로 이동한다.

---

## 3. 학습 내용

### 1. StringBuilder

String은 immutable 하지만 StringBuilder는 mutable 합니다.

String 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않습니다. 따라서 + 연산은 새로운 String 객체를 생성하고
해당 객체에 연결된 문자열을 지정하여 이를 참조하도록 합니다. 따라서 문자 연산이 많은 경우 성능이 좋지 않습니다.

하지만 간단하게 사용 가능하고, 동기화를 신경쓰지 않아도 되기 때문에 자유롭게 공유할 수 있습니다.

StringBuilder는 String과 다르게 가변적이며 기존 객체의 공간이 부족해질 경우, 버퍼 크기를 늘리며 유연하게 동작합니다.

### 2. Response : Content-Length

대부분의 브라우저는 Content-Length 헤더가 없어도 오류를 발생시키지 않습니다.

- Transfer-Encoding: Chunked
  > 웹 서버가 응답 본문을 전송할 때, Transfer-Encoding 헤더를 사용하여 "chunked" 전송 인코딩을 지원할 수 있습니다. 
  > 
  > 이 경우에는 응답 본문이 여러 조각으로 나뉘어 전송되며, 브라우저는 이러한 조각들을 조합하여 전체 응답을 복원합니다.

- Connection close
  > 만약 서버가 응답을 전송한 후에 연결을 닫는다면, 브라우저는 서버로부터 응답을 받고 나서 연결이 닫혔다는 것을 확인하고, 그 이후에 추가 데이터가 없음을 이해합니다.
  > 하지만 일부 브라우저는 정상적으로 동작하지 않을 수 있기 때문에 유의해야 합니다.

### 3. Content-Type : charset

브라우저는 Content-Type 헤더의 charset 파라미터가 없으면 이를 추정하려고 시도합니다.

- BOM (Byte Order Mark)
  > 일부 텍스트 파일은 BOM이라는 바이트 순서 표시를 사용하여 인코딩을 나타냅니다.
  > 
  > 브라우저는 BOM을 사용하여 적절한 문자 인코딩을 추측할 수 있습니다.

- 언어 감지
  > 라우저는 페이지의 언어를 감지하려고 시도합니다.
  > 특정 언어에는 일반적으로 사용되는 문자 집합이 있으며, 브라우저는 이 정보를 사용하여 적절한 문자 인코딩을 선택합니다.

- 기본 값 설정
  > 대부분의 브라우저는 일반적으로 UTF-8을 기본 값으로 사용합니다.
  > 
  > UTF-8은 현대적인 웹에서 널리 사용되는 문자 인코딩 방식 중 하나입니다.

---

## 4. 문제 해결

### 1. 로그인 여부 확인 방법

- 문제
  > 처음에는 try-catch를 사용해 오류로 구분하고자 했습니다. 하지만 로그인이 안된 상태는 쿠키가 없을때,
  > 쿠키 조회가 안될때이며, 모두 동일한 결과(로그인 화면으로 이동)이므로 중복되는 코드가 발생했습니다.
  > 
  > 쿠키가 null일때 조회하면 NullPointerException이 발생하니 조회 결과가 null일때도 동일한
  > 예외를 발생시키는 방법도 생각했지만 이 경우 쿠키가 없는건지, 조회 결과가 없는건지 구분하기 힘들었습니다.

- 해결 방안
  > 조건문으로 쿠키가 없는지 먼저 검사하고, 조회 결과가 없는건지 확인하도록 하여 중복 코드가 없으며,
  > 적은 코드로 구현할 수 있었습니다.

### 2. 동적인 HTML 구현

- 문제 1
  > stringBuilder의 replace를 사용할 경우 인덱스를 입력해야 했으며 매번 인덱스를 찾을 경우 가독성이 좋지 않아 
  > 유지보수가 힘들것이라 판단했습니다.

- 문제 2
  > String의 replace 함수를 사용해 키워드마다 내용을 수정하는 방식을 사용했습니다. 
  > 이 과정에서 `Result of 'String.replace()' is ignored`경고문이 발생했습니다.

- 해결 방안
  > String의 replace 함수는 새로운 String 객체를 만든다는 것을 알게 되어,
  > `new`를 사용하여 새로운 String 객체를 반환하도록 하여 해결했습니다.

---

## 5. 기록

[Respone : Content-Length](http/content-lenght.md)

---

## 6. 참고 문서

[MDN - Transfer Encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)
